<<"SIEAMA">>
{"FK",{__block__,[],[{defmodule,[{line,1}],[{__aliases__,[{line,1}],[Math]},[{do,{__block__,[],[{def,[{line,2}],[{double_each,[{line,2}],[[{|,[{line,2}],[{head,[{line,2}],nil},{tail,[{line,2}],nil}]}]]},[{do,[{|,[{line,3}],[{*,[{line,3}],[{head,[{line,3}],nil},2]},{double_each,[{line,3}],[{tail,[{line,3}],nil}]}]}]}]]},{def,[{line,6}],[{double_each,[{line,6}],[[]]},[{do,[]}]]}]}}]]},{{.,[{line,11}],[{__aliases__,[{line,11}],[Math]},double_each]},[{line,11}],[[1,2,3]]}]},[],#{__struct__=>Elixir.Macro.Env,aliases=>[],context=>nil,context_modules=>[],file=><<"nofile">>,function=>nil,functions=>[{Elixir.Kernel,[{!=,2},{!==,2},{*,2},{**,2},{+,1},{+,2},{++,2},{-,1},{-,2},{--,2},{/,2},{<,2},{<=,2},{==,2},{===,2},{=~,2},{>,2},{>=,2},{abs,1},{apply,2},{apply,3},{binary_part,3},{binary_slice,2},{binary_slice,3},{bit_size,1},{byte_size,1},{ceil,1},{div,2},{elem,2},{exit,1},{floor,1},{function_exported?,3},{get_and_update_in,3},{get_in,2},{hd,1},{inspect,1},{inspect,2},{is_atom,1},{is_binary,1},{is_bitstring,1},{is_boolean,1},{is_float,1},{is_function,1},{is_function,2},{is_integer,1},{is_list,1},{is_map,1},{is_map_key,2},{is_number,1},{is_pid,1},{is_port,1},{is_reference,1},{is_tuple,1},{length,1},{macro_exported?,3},{make_ref,0},{map_size,1},{max,2},{min,2},{node,0},{node,1},{not,1},{pop_in,2},{put_elem,3},{put_in,3},{rem,2},{round,1},{self,0},{send,2},{spawn,1},{spawn,3},{spawn_link,1},{spawn_link,3},{spawn_monitor,1},{spawn_monitor,3},{struct,1},{struct,2},{struct!,1},{struct!,2},{throw,1},{tl,1},{to_timeout,1},{trunc,1},{tuple_size,1},{update_in,3}]}],lexical_tracker=>nil,line=>1,macro_aliases=>[],macros=>[{Elixir.Kernel,[{!,1},{&&,2},{..,0},{..,2},{..//,3},{<>,2},{@,1},{alias!,1},{and,2},{binding,0},{binding,1},{dbg,0},{dbg,1},{dbg,2},{def,1},{def,2},{defdelegate,2},{defexception,1},{defguard,1},{defguardp,1},{defimpl,2},{defimpl,3},{defmacro,1},{defmacro,2},{defmacrop,1},{defmacrop,2},{defmodule,2},{defoverridable,1},{defp,1},{defp,2},{defprotocol,2},{defstruct,1},{destructure,2},{get_and_update_in,2},{get_in,1},{if,2},{in,2},{is_exception,1},{is_exception,2},{is_nil,1},{is_non_struct_map,1},{is_struct,1},{is_struct,2},{match?,2},{or,2},{pop_in,1},{put_in,2},{raise,1},{raise,2},{reraise,2},{reraise,3},{sigil_C,2},{sigil_D,2},{sigil_N,2},{sigil_R,2},{sigil_S,2},{sigil_T,2},{sigil_U,2},{sigil_W,2},{sigil_c,2},{sigil_r,2},{sigil_s,2},{sigil_w,2},{tap,2},{then,2},{to_char_list,1},{to_charlist,1},{to_string,1},{unless,2},{update_in,2},{use,1},{use,2},{var!,1},{var!,2},{|>,2},{||,2}]}],module=>nil,requires=>[Elixir.Application,Elixir.Kernel],tracers=>[],versioned_vars=>#{}}}
{"FK",1,{elixir_module,compile},[Elixir.Math,{__block__,[],[{def,[{line,2}],[{double_each,[{line,2}],[[{|,[{line,2}],[{head,[{line,2}],nil},{tail,[{line,2}],nil}]}]]},[{do,[{|,[{line,3}],[{*,[{line,3}],[{head,[{line,3}],nil},2]},{double_each,[{line,3}],[{tail,[{line,3}],nil}]}]}]}]]},{def,[{line,6}],[{double_each,[{line,6}],[[]]},[{do,[]}]]}]},[],false,#{__struct__=>Elixir.Macro.Env,aliases=>[],context=>nil,context_modules=>[Elixir.Math],file=><<"nofile">>,function=>nil,functions=>[{Elixir.Kernel,[{!=,2},{!==,2},{*,2},{**,2},{+,1},{+,2},{++,2},{-,1},{-,2},{--,2},{/,2},{<,2},{<=,2},{==,2},{===,2},{=~,2},{>,2},{>=,2},{abs,1},{apply,2},{apply,3},{binary_part,3},{binary_slice,2},{binary_slice,3},{bit_size,1},{byte_size,1},{ceil,1},{div,2},{elem,2},{exit,1},{floor,1},{function_exported?,3},{get_and_update_in,3},{get_in,2},{hd,1},{inspect,1},{inspect,2},{is_atom,1},{is_binary,1},{is_bitstring,1},{is_boolean,1},{is_float,1},{is_function,1},{is_function,2},{is_integer,1},{is_list,1},{is_map,1},{is_map_key,2},{is_number,1},{is_pid,1},{is_port,1},{is_reference,1},{is_tuple,1},{length,1},{macro_exported?,3},{make_ref,0},{map_size,1},{max,2},{min,2},{node,0},{node,1},{not,1},{pop_in,2},{put_elem,3},{put_in,3},{rem,2},{round,1},{self,0},{send,2},{spawn,1},{spawn,3},{spawn_link,1},{spawn_link,3},{spawn_monitor,1},{spawn_monitor,3},{struct,1},{struct,2},{struct!,1},{struct!,2},{throw,1},{tl,1},{to_timeout,1},{trunc,1},{tuple_size,1},{update_in,3}]}],lexical_tracker=>nil,line=>1,macro_aliases=>[],macros=>[{Elixir.Kernel,[{!,1},{&&,2},{..,0},{..,2},{..//,3},{<>,2},{@,1},{alias!,1},{and,2},{binding,0},{binding,1},{dbg,0},{dbg,1},{dbg,2},{def,1},{def,2},{defdelegate,2},{defexception,1},{defguard,1},{defguardp,1},{defimpl,2},{defimpl,3},{defmacro,1},{defmacro,2},{defmacrop,1},{defmacrop,2},{defmodule,2},{defoverridable,1},{defp,1},{defp,2},{defprotocol,2},{defstruct,1},{destructure,2},{get_and_update_in,2},{get_in,1},{if,2},{in,2},{is_exception,1},{is_exception,2},{is_nil,1},{is_non_struct_map,1},{is_struct,1},{is_struct,2},{match?,2},{or,2},{pop_in,1},{put_in,2},{raise,1},{raise,2},{reraise,2},{reraise,3},{sigil_C,2},{sigil_D,2},{sigil_N,2},{sigil_R,2},{sigil_S,2},{sigil_T,2},{sigil_U,2},{sigil_W,2},{sigil_c,2},{sigil_r,2},{sigil_s,2},{sigil_w,2},{tap,2},{then,2},{to_char_list,1},{to_charlist,1},{to_string,1},{unless,2},{update_in,2},{use,1},{use,2},{var!,1},{var!,2},{|>,2},{||,2}]}],module=>nil,requires=>[Elixir.Application,Elixir.Kernel],tracers=>[],versioned_vars=>#{}}]}
{"FK2",{elixir_module,compile}}
{"FK",11,{Elixir.Math,double_each},[[1,2,3]]}
{"FK2",{Elixir.Math,double_each}}
