export const frontmatter = { order: 1 };

# Lists - Linked Data Structures

Lists in Elixir are **linked lists**, not arrays. This fundamental difference affects how we work with them:

- **Structure**: Each element points to the next, forming a chain
- **Performance**: O(1) for prepending, O(n) for appending or accessing by index
- **Immutability**: Operations create new lists, original remains unchanged
- **Memory**: Shared structure between versions (structural sharing)

Lists are the backbone of functional programming in Elixir, perfect for recursive operations and pattern matching.

## When to Use Lists

âœ… **Use lists when:**

- Working with sequential data processing
- Building data recursively
- Prepending is the primary operation
- Pattern matching on head/tail

âŒ **Avoid lists when:**

- Need random access by index
- Frequently appending elements
- Working with large datasets requiring lookups

export const defaultCode = `# Creating lists
empty = []
numbers = [1, 2, 3, 4, 5]
mixed = [1, :atom, "string", %{key: "value"}]

# The cons operator | builds lists
# Prepend - O(1) operation
list = [0 | numbers]
IO.inspect(list)

# Pattern matching - the heart of list processing
[head | tail] = numbers
IO.puts("Head: #{head}, Tail: #{inspect(tail)}")

[first, second | rest] = numbers
IO.puts("First: #{first}, Second: #{second}")

# List operations
# O(n) for first list
concatenated = [1, 2] ++ [3, 4]
# Removes first occurrence
subtracted = [1, 2, 3, 2] -- [2]
IO.inspect(concatenated)
IO.inspect(subtracted)

# Recursive processing example
defmodule ListSum do
  def sum([]), do: 0
  def sum([head | tail]), do: head + sum(tail)
end

IO.puts("Sum: #{ListSum.sum(numbers)}")

# Performance tip: Always prepend, then reverse if needed
result =
  [1, 2, 3]
  |> Enum.reduce([], fn x, acc -> [x * 2 | acc] end)
  |> Enum.reverse()

IO.inspect(result)
`
