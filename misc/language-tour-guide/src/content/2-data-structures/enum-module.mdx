export const frontmatter = { order: 40 };

# The Enum Module - Collection Processing

The Enum module is Elixir's Swiss Army knife for working with collections. It provides 100+ functions that work with any **Enumerable** data type (lists, maps, ranges, etc.).

**Key Concepts:**

- **Eager evaluation**: Processes entire collection immediately
- **Enumerable protocol**: Works with any collection that implements it
- **Functional approach**: Transform data without mutation
- **Composable**: Chain operations with the pipe operator

**Common Patterns:**

- `map` - Transform each element
- `filter` - Select elements matching criteria
- `reduce` - Aggregate to single value
- `each` - Side effects only

export const defaultCode = `# Essential Enum functions
list = [1, 2, 3, 4, 5]

# Transform with map
doubled = Enum.map(list, fn x -> x * 2 end)

# Shorter syntax with capture operator
squared = Enum.map(list, &(&1 * &1))
IO.inspect(doubled)
IO.inspect(squared)

# Filter elements
evens = Enum.filter(list, fn x -> rem(x, 2) == 0 end)
IO.inspect(evens)

# Reduce to single value
sum = Enum.reduce(list, 0, fn x, acc -> x + acc end)
product = Enum.reduce(list, 1, &(&1 * &2))
IO.puts("Sum: #{sum}, Product: #{product}")

# Find and check
first_even = Enum.find(list, fn x -> rem(x, 2) == 0 end)
all_positive = Enum.all?(list, &(&1 > 0))
any_negative = Enum.any?(list, &(&1 < 0))
IO.puts("First even: #{first_even}")
IO.puts("All positive? #{all_positive}")

# Take, drop, and slice
first_three = Enum.take(list, 3)
last_two = Enum.take(list, -2)
without_first = Enum.drop(list, 1)
IO.inspect(first_three)
IO.inspect(without_first)

# Combine operations with pipe
result =
  list
  |> Enum.filter(&(&1 > 2))
  |> Enum.map(&(&1 * 3))
  |> Enum.sum()

IO.puts("Pipeline result: #{result}")

# Works with any enumerable
range_sum = Enum.sum(1..100)
map_values = Enum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v * 2} end)
IO.puts("Sum 1-100: #{range_sum}")
IO.inspect(map_values)
`
