export const frontmatter = { order: 44 };

# MapSets - Unique Collections

MapSets store unique values without duplicates, providing efficient membership testing and set operations. Built on maps, they're optimized for checking if a value exists.

**Characteristics:**

- **Uniqueness**: Automatically removes duplicates
- **O(log n) operations**: Fast membership testing
- **No ordering**: Don't rely on element order
- **Set operations**: Union, intersection, difference

**When to use:**

- Removing duplicates
- Fast membership checks
- Set operations (union, intersection)
- Tracking unique items

export const defaultCode = `# Creating MapSets
# Duplicates removed
from_list = MapSet.new([1, 2, 3, 2, 1])
empty = MapSet.new()
from_range = MapSet.new(1..5)

IO.inspect(from_list, label: "Unique values")

# Basic operations

set = MapSet.new([1, 2, 3])

# Add elements

added = MapSet.put(set, 4)
# No change
added_dup = MapSet.put(added, 4)
IO.inspect(added)
IO.puts("Same after adding duplicate? #{added == added_dup}")

# Remove elements

removed = MapSet.delete(added, 2)
IO.inspect(removed)

# Membership testing - O(log n)

IO.puts("Contains 3? #{MapSet.member?(set, 3)}")
IO.puts("Contains 10? #{MapSet.member?(set, 10)}")
IO.puts("Size: #{MapSet.size(set)}")

# Set operations

set_a = MapSet.new([1, 2, 3, 4])
set_b = MapSet.new([3, 4, 5, 6])

# All elements
union = MapSet.union(set_a, set_b)
# Common elements
intersection = MapSet.intersection(set_a, set_b)
# In A, not in B
difference = MapSet.difference(set_a, set_b)

IO.inspect(union, label: "Union")
IO.inspect(intersection, label: "Intersection")
IO.inspect(difference, label: "Difference")

# Practical example: Remove duplicates

words = ["the", "quick", "brown", "fox", "the", "fox"]

unique_words =
  words
  |> MapSet.new()
  |> MapSet.to_list()

IO.inspect(unique_words, label: "Unique words")`
