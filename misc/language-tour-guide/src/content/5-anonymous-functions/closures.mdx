export const frontmatter = { order: 3 };

# Closures

Anonymous functions can also access variables that are in scope when the function is defined.

This is typically referred to as closures, as they close over their scope.

<EditorCode>
```elixir
a = 3

increment_by_a = fn x -> x + a end

# Try assigning 4 to variable 'a' after the function is defined and before it's called
# Does it affect the function?
IO.inspect increment_by_a.(2), label: "Call to increment_by_a returns"
```
</EditorCode>

# Clauses and guards

Similar to `case/2`, we can pattern match on the arguments of anonymous functions as well as define multiple clauses and guards - see the example.

The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.

<EditorCode>
```elixir
# Try adding another clause with three arguments: x, y and z
f = fn
  x, y when x > 0 -> x + y
  a, b -> a * b
end

# Let's change 1 to -1
IO.inspect f.(1, 3), label: "Call to f returns"
```
</EditorCode>
