# Booleans and nil

## Booleans

Elixir supports `true` and `false` as booleans, and provides logical `and`, `or` and `not` operators to work on them.

Note that `and` and `or` are short-circuit: if the left-hand side determines the result, the right-hand side won't even be evaluated. It's especially important when doing side effects.

The boolean values:

```elixir
true
```

```elixir
false
```

Are they equal?

```elixir
true == false
```

Logical `and` of two true values:

```elixir
true and true
```

Short-circuit `and` - try changing `true` to `IO.inspect(true)` to see if it gets evaluated:

```elixir
false and true
```

Logical `or`:

```elixir
false or is_boolean(true)
```

Logical `not`:

```elixir
not true
```

Beyond strict booleans, Elixir provides operators that work with any value.

## Booleans and nil

Elixir also provides the concept of `nil`, to indicate the absence of a value, and a set of logical operators that also manipulate `nil`: `||`, `&&`, and `!`. For these operators, `false` and `nil` are considered "falsy", all other values are considered "truthy".

As a rule of thumb, use `and`, `or` and `not` when you are expecting booleans. If any of the arguments are non-boolean, use `&&`, `||` and `!`.

Using `&&` with booleans:

```elixir
true && false
```

`nil` is falsy, so `&&` short-circuits:

```elixir
nil && 13
```

`true` is truthy, so `&&` returns the right-hand side:

```elixir
true && 17
```

`||` returns the first truthy value - try changing `1` to `IO.inspect("foo")`:

```elixir
1 || true
```

`false` is falsy, so `||` returns the right-hand side:

```elixir
false || 11
```

The `!` operator - try `!1` and `!nil`:

```elixir
!true
```
