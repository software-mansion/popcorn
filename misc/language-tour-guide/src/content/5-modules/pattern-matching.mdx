export const frontmatter = { order: 10 };

# Pattern Matching and Destructuring

Pattern matching is one of Elixir's most powerful features.

You can destructure complex data structures and bind variables in a single expression.

If a pattern doesn't match, Elixir raises a MatchError.

export const defaultCode = `# List pattern matching
[head | tail] = [1, 2, 3, 4]
IO.puts("Head: #{head}, Tail: #{inspect(tail)}")

# Map pattern matching

%{name: name, age: age} = %{name: "Alice", age: 30, city: "NYC"}
IO.puts("Name: #{name}, Age: #{age}")

# Tuple pattern matching with ignored values

{:ok, result, \_metadata} = {:ok, "data", %{source: "database", query_time_ms: 10}}
IO.puts("Result: #{result}")

# Matching specific values

{:error, \_} = {:error, "Something went wrong"}
IO.puts("Matched an error tuple")`
