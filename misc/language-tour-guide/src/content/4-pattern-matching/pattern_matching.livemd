# Pattern Matching

You've seen the `=` operator used to assign a value to the variable.
`=` in Elixir is called _the match operator_.
As it turns out, it can do much more than just a simple assignment!

Check out the example - after the `1` is assigned to `x`, it can be used for matching.
Line `1 = x` is legal and means "match x against pattern 1", which succeeds.

Test out what happens if the pattern becomes `2` or when you try to match the variable before an assignment.
Spoiler alert - you'll see some errors. Notice the difference between them - one occurs in runtime,
while the other occurs during compilation.

Matching identical values:

```elixir
1 = 1
```

Assigning to a variable:

```elixir
x = 1
```

Matching a variable's value:

```elixir
1 = x
```

```elixir
x = 2

# ðŸ’¡ Try uncommenting the following lines. What happens?
# 2 = x
# 2 = new_variable
```

Now that you understand how the match operator works, let's explore how it applies to different data structures, starting with tuples.

## Matching Tuples

Thanks to pattern matching, you can "extract" each tuple element into a variable.
The pattern must be of the same size for the match to succeed.

In Elixir, it is common to return a tuple `{:ok, result}` on success and either `:error` atom
or `{:error, reason}` tuple in case of failure.
You can also use atoms in the pattern to match on such results.

Extracting tuple elements:

```elixir
{a, b} = {:hello, "world"}

IO.inspect(a, label: "a")
IO.inspect(b, label: "b")
```

The pattern must match the tuple size:

```elixir
# â—ï¸ This code raises an error!
# ðŸ’¡ Let's modify the pattern on the left to fix the error
{x, y} = {:hello, "world", 42}

IO.inspect(x, label: "x")
IO.inspect(y, label: "y")
```

Matching on tagged tuples:

```elixir
# ðŸ’¡ Find out what happens if you replace `:answer`
# with a different atom
{:ok, answer} = Map.fetch(%{answer: 42}, :answer)
answer
```

Just like tuples, lists can also be destructured using pattern matching, but with some unique capabilities.

## Matching Lists

List matching works similarly to tuples - you can extract every element of the list.
The sizes of pattern and the value must equal for a successful matching.

There is, however, a special pattern using the "cons" operator (`|`, see [the lists section](../data-structures/lists-basics)).
It allows matching on the first element of the list (called "head")
and the rest of the list (called "tail") similarly to the way you can build a list.

Extracting list elements:

```elixir
[j, k, l] = [1, 2, 3]

IO.inspect(j, label: "j")
IO.inspect(k, label: "k")
IO.inspect(l, label: "l")
```

Using head/tail pattern:

```elixir
# ðŸ’¡ Try to match empty (`[]`) or single element list (`[1]`)
[head | tail] = [1, 2, 3]

IO.inspect(head, label: "head")
IO.inspect(tail, label: "tail")
```

The `|` operator works for both prepending and destructuring:

```elixir
[head | tail] = [1 | [2 | [3 | []]]]

IO.inspect(head, label: "head")
IO.inspect(tail, label: "tail")
```

Creating a new list with different head:

```elixir
[head | tail] = [1, 2, 3]
[0 | tail]
```

Maps also support pattern matching with their own unique characteristics that make them particularly flexible.

## Matching Maps

Patterns for maps can extract the value of any key or ensure that a specified key has a provided value.
The pattern doesn't have to be exhaustive and cover every entry stored inside the map.

Extracting a value by key:

```elixir
map = %{"a" => 1, :b => 2, :c => "c"}
%{"a" => one} = map
one
```

An empty map pattern matches any map:

```elixir
%{} = %{}
%{} = map
```

Enforcing a specific value for `:c`:

```elixir
# ðŸ’¡ Try changing "c" to something else and see the result
%{:b => two, :c => "c"} = map
two
```

For atom keys, a special syntax is available:

```elixir
%{c: cee} = map
cee
```

Beyond these basic patterns, Elixir provides additional constructs that give you even more control over pattern matching.

## Special patterns

There are some additional constructs you may use when building patterns.

### The pin operator

In Elixir, variables can be rebound, i.e. assigned to a new value.
If you want to avoid that in a pattern and match against the actual value assigned to that variable,
you must use the pin `^` operator.
It can be a part of more complex patterns.

Variables can be rebound:

```elixir
x = 1
x = 2
x
```

Using the pin operator to match against current value:

```elixir
# ðŸ’¡ Let's see what will happen if you change the value to 3
x = 2
# This is the equivalent of
^x = 2
```

Pin operator in complex patterns:

```elixir
{y, ^x} = {3, 2}
{y, x}
```

### Repeated variables

If a variable occurs more than once in the pattern, it must bind to the same value.
Otherwise, the match will fail.

Matching repeated variables:

```elixir
# ðŸ’¡ Try changing one of the values in tuple on the right
{z, z} = {3, 3}
z
```

### Ignore pattern

If you only want to extract some of the values, you may use the ignore pattern: `_`.
It is a special variable that can never be read from.
Optionally, for readability, you may use a variable with `_` prefix, e.g. `_ignored`.

Using underscore to ignore values:

```elixir
# ðŸ’¡ Let's try using the underscore
[head | _] = [1, 2, 3]
head
```

Named ignore pattern is is slightly different, but yields a warning:

```elixir
{:error, _reason} = {:error, :enoent}

# ðŸ’¡ Let's try using _reason
:ok
```
