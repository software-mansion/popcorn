export const frontmatter = {order: 2}

# Case - Pattern Matching Control Flow

## Theory

`case` is pattern matching in action - it compares a value against multiple patterns until one matches. It's one of Elixir's most powerful control structures.

**Key features:**
- **Pattern matching**: Each clause is a pattern
- **Guards**: Additional conditions with `when`
- **Variable binding**: Patterns can bind variables
- **Exhaustive**: Should handle all cases (use `_` for catch-all)

**When to use:**
- Multiple patterns to match
- Destructuring data while branching
- Replacing switch/case from other languages
- Complex conditional logic with pattern matching

export const defaultCode = `# Basic case statement
value = {:ok, "Success!"}

result =
  case value do
    {:ok, msg} -> "It worked: #{msg}"
    {:error, reason} -> "Failed: #{reason}"
    _ -> "Unknown response"
  end

IO.puts(result)

# Pattern matching with variable binding
user_role = {:admin, "Alice"}

case user_role do
  {:admin, name} ->
    IO.puts("Admin user: #{name}")

  {:user, name} ->
    IO.puts("Regular user: #{name}")

  {:guest, _} ->
    IO.puts("Guest user")

  nil ->
    IO.puts("No user")
end

# Using guards
number = 15

case number do
  n when n < 0 -> IO.puts("Negative")
  0 -> IO.puts("Zero")
  n when n > 0 and n <= 10 -> IO.puts("Small positive")
  n when n > 10 -> IO.puts("Large positive")
end

# Pattern matching lists
list = [1, 2, 3]

case list do
  [] -> "Empty list"
  [single] -> "One element: #{single}"
  [first, second] -> "Two elements: #{first}, #{second}"
  [head | tail] -> "Head: #{head}, Tail length: #{length(tail)}"
end
|> IO.puts()

# Pin operator in case
expected = 42
value = 42

case value do
  ^expected -> IO.puts("Matches pinned value!")
  other -> IO.puts("Got #{other}, expected #{expected}")
end
`