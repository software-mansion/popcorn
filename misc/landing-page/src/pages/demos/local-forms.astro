---
import Layout from "../../layouts/Layout.astro";
import Section from "../../components/Section.astro";
---

<Layout>
  <Section background="light">
    <header class="mb-4 text-center">
      <h1
        class="font-handjet text-brown-header mb-4 text-4xl font-bold md:text-6xl"
      >
        Local Forms
      </h1>
      <p class="mx-auto max-w-2xl">
          The following example implements phoenix forms using LocalLiveView.
      </p>
      <p class="mx-auto max-w-2xl">
          The form_demo is built as html page with a single form and a rendered list of users (usernames and emails).
          List of users is stored in local live view process memory.
          The form handles onchange and onsubmit LocalLiveView events.
          The change event triggers validate function that looks through already saved users and makes sure that
          new username or email isn't already present in the users list. The submit event adds a new user to the user list.
      </p>
    </header>
    <style></style>
    <div
      class="bg-light-20 border-brown-header mx-w-md mt-8 overflow-hidden rounded-2xl border-2 shadow-lg"
    >
      <div class="bg-brown-header px-6 py-3">
        <h2
          class="font-handjet text-light-20 text-center text-xl tracking-wide"
        >
          Add New User
        </h2>
      </div>
      <div
        data-pop-view="FormDemoLocal"
        class="local_forms flex max-w-[412px] flex-col gap-4 p-8"
      >
      </div>
    </div>
  </Section>
</Layout>

<style is:global>
  .local_forms .input {
    border: 2px solid #58330c;
    border-radius: 0.5rem;
    width: 100%;
    padding: 0.75rem 1rem;
    background: #fffdf5;
    color: #301b05;
    transition: all 0.2s ease;
  }

  .local_forms .input:focus {
    outline: none;
    border-color: #ef7c00;
    box-shadow: 0 0 0 3px rgba(239, 124, 0, 0.1);
  }

  .local_forms .input::placeholder {
    color: #696057;
  }

  .local_forms {
    color: #301b05;
  }

  .local_forms form {
    margin-bottom: 1rem;
  }

  .local_forms label {
    font-weight: 600;
    color: #58330c;
    margin-bottom: 0.25rem;
  }

  .ghost-button {
    padding: 0.75rem 1.5rem;
    border: 2px solid #58330c;
    background: transparent;
    color: #58330c;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 1rem;
    font-weight: 600;
  }

  .ghost-button:hover {
    background: #ef7c00;
    border-color: #ef7c00;
    color: #fffdf5;
  }

  .ghost-button:disabled {
    border-style: dashed;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .ghost-button:disabled:hover {
    background: transparent;
    border-color: #58330c;
    color: #58330c;
  }
</style>

<script>
const events = [
  {js_event: "click", pop_event: "pop-click"},
  {js_event: "keydown", pop_event: "pop-keydown"},
  {js_event: "submit", pop_event: "pop-submit"},
  {js_event: "input", pop_event: "pop-change"}
]
  
let focused_el = document.activeElement;
  
async function setup() {
  const popcorn = await Popcorn.init({
    debug: true,
    bundlePath: "../wasm/local_forms.avm",
    wasmDir: "/wasm/"
  })
  document.addEventListener("popRender", (event) => { afterRenderBind(event, popcorn) });
  const { data, durationMs } = await popcorn.call({ "views": find_predefined_views()}, {
    timeoutMs: 10_000,
  });
}
    
async function afterRenderBind(renderEvent, popcorn) {
  const view = renderEvent.detail.view
  const view_element = find_element(view)
  if (view_element.dataset.popcornBound) return;
  focused_el.focus()
  events.forEach(({js_event: js_event, pop_event: pop_event}) => {
    view_element.addEventListener(js_event, async (e) => {
      const target_el = e.target.closest(`[${pop_event}]`);
      console.log({event: e, target_el: target_el, pop_event: pop_event})
      if (target_el && view_element.contains(target_el)) {
        handlePopEvent(e, target_el, pop_event, popcorn, view);
      }
    });
  })
  view_element.dataset.popcornBound = "true";
}

async function handlePopEvent(e, target_el, pop_event, popcorn, view) {
  focused_el = document.activeElement
  const value = extractElementValue(e, target_el)
  try {
    const { data, durationMs } = await popcorn.call({ "view": view, "event": pop_event, 
      "payload": {"event": target_el.getAttribute(pop_event), "value": value} }, {
      timeoutMs: 10_000,
    });
  } catch (error) {
    console.log(error)
  }
}

function extractElementValue(e, el) {
  let value
  if(el instanceof HTMLFormElement){
    e.preventDefault();
    const inputs = el.querySelectorAll('input');
    const inputsArray = Array.from(inputs)
    value = inputsArray.reduce((acc, input) => {
      acc[input.name] = input.value;
      return acc;
    }, {});
  } else if (el.hasAttribute(value))  {
    value = el.value;
  }
  return value;
};
  
// TODO this is a mock for heex templating inside index.html file
function find_predefined_views() {
  let elements = document.querySelectorAll('[data-pop-view]');
  elements = Array.from(elements)
  return elements.map(el => el.getAttribute("data-pop-view"))
}

function find_view(element) {
  while(element) {
    if(element.hasAttribute("data-pop-view")) {
      return element.getAttribute("data-pop-view")
    }
    element = element.parentElement
  }
  return null
}

function find_element(view) {
  let elements = document.querySelectorAll('[data-pop-view]');
  elements = Array.from(elements)
  const found = elements.find((element) => element.getAttribute("data-pop-view") == view);
  return found
}

document.addEventListener("DOMContentLoaded", setup);
document.addEventListener("astro:page-load", setup);
</script>
