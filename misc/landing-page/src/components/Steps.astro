---
import Step from "./Step.astro";
import Section from "./Section.astro";
---

<Section
  id="features"
  background="light"
  class="mt-20 gap-20 md:gap-36 lg:mt-20"
>
  <Step n="01">
    <Fragment slot="header-title">Elixir, meet <br /> WebAssembly.</Fragment>
    <Fragment slot="title">Compile your Elixir to Wasm.</Fragment>
    <Fragment slot="description">
      Popcorn bridges your Elixir code with Wasm-compiled AtomVM runtime. No
      need to learn a new language – just use the one you already love.
    </Fragment>
  </Step>
  <Step n="02">
    <Fragment slot="header-title">Your code <br /> is great.</Fragment>
    <Fragment slot="title">Use your existing code without any changes.</Fragment
    >
    <Fragment slot="description"
      >With Popcorn, you don’t need to rewrite or refactor your code. It runs
      plain Elixir as-is (including OTP patterns and supervision trees) right
      inside the browser.
    </Fragment>
  </Step>
  <Step n="03">
    <Fragment slot="header-title">No internet? <br /> No problem.</Fragment>
    <Fragment slot="title">Run everything in the browser</Fragment>
    <Fragment slot="description"
      >Popcorn runs fully in-browser, which makes it ideal for many use cases,
      like offline, local-first applications. No servers or internet connection
      required.</Fragment
    >
  </Step>
  <Step n="04">
    <Fragment slot="header-title">Built for <br /> stability.</Fragment>
    <Fragment slot="title">Don’t worry about the performance.</Fragment>
    <Fragment slot="description"
      >Compared to AtomVM, Popcorn enhances Elixir-JavaScript communication,
      reduces the number of crashes, and improves memory handling for your app
      to run smoothly.</Fragment
    >
  </Step>
</Section>

<script>
  function setupStepAnimation() {
    const section = document.querySelector("#features")!;
    const steps = document.querySelectorAll<HTMLElement>("[data-step]");

    const threshold = 50;
    const duration = 400;

    let currentStep = 0;
    let isInViewport = false;
    let ticking = false;

    function updateVisibility() {
      console.log("updateVisibility", currentStep);
      const step = steps[currentStep];
      const stepRect = step.getBoundingClientRect();
      const nextStep = steps[currentStep + 1];
      const nextStepRect = nextStep?.getBoundingClientRect();

      if (!nextStepRect) return;

      const distance = nextStepRect?.top - stepRect.top;

      const opacity = Math.max(
        Math.min((distance - threshold) / duration, 1),
        0,
      );

      const isCurrentStepIsInBottomHalfOfViewport =
        stepRect.top + stepRect.height / 2 - threshold * 2 >
        window.innerHeight / 2;

      step.style.opacity = String(opacity);

      nextStep.style.opacity = String(1 - opacity);

      if (Math.abs(distance) < threshold && currentStep < steps.length - 2) {
        currentStep += 1;
      }

      if (isCurrentStepIsInBottomHalfOfViewport && currentStep > 0) {
        currentStep -= 1;
      }
    }

    function handleScroll() {
      if (!ticking && isInViewport) {
        requestAnimationFrame(() => {
          updateVisibility();

          ticking = false;
        });

        ticking = true;
      }
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          isInViewport = entry.isIntersecting;
        });
      },
      {
        threshold: 0,
      },
    );

    observer.observe(section);

    // Initial visibility update
    steps.forEach((_) => {
      updateVisibility();
    });

    window.addEventListener("scroll", handleScroll);
  }

  function setup() {
    setupStepAnimation();
  }

  document.addEventListener("DOMContentLoaded", setup);
  document.addEventListener("astro:page-load", setup);
</script>
